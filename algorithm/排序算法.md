# 归并排序

### 题目练习

#### 1.递归实现归并算法

#### 2.非递归实现归并算法

#### 3.其他经典题目

3.1小和问题 ，求数组中每个数最右标小于自己的数之和并累加

3.2逆序对计算

3.3给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 区间和的个数 。
https://leetcode.cn/problems/count-of-range-sum/submissions/思路：

1）求前缀和。

2）问题转换为左前缀和在[x-lower,y-upper]区间之间

3）把求2）的数量转换为归并排序

4）想出归并排序不回退的方法

### leetcode问题记录：

1.加减时候超出int范围

2.超出时间

```
//第一次提交的时候超出了处理时间
for(int i=mid+1;i<=right;i++){
    long min =sum[i]-upper;
    long max =sum[i]-lower;
    for(int j=left;j<=mid;j++ ){
        if(sum[j]>=min && sum[j]<=max){
            result ++;
        }
    }
}
//改为了下面的处理时间就没超出
int windowL = left;
int windowR = left;
for(int i=mid+1;i<=right;i++){
    long min =sum[i]-upper;
    long max =sum[i]-lower;
    while (windowR <= mid && sum[windowR] <= max) {
        windowR++;
    }
    while (windowL <= mid && sum[windowL] < min) {
        windowL++;
    }
    result += windowR - windowL;
}
```

# 快速排序

步骤：

1.选基准点

2.比基准点小的数往左排，比基准点大的往右排



### 快排与归并的比较

邻的内存位置往往比访问分散在内存中的内存位置要快。快速排序中的分区步骤通常具有很好的局部性，因为它访问前后附近的连续数组元素。因此，快速排序往往比其他排序算法（如heapsort）的性能要好得多，尽管它通常执行大致相同数量的比较和交换，因为在heapsort的情况下，访问更加分散。

此外，快速排序通常比其他排序算法快得多，因为它可以就地操作，而不需要创建任何辅助数组来保存临时值。与merge-sort相比，这是一个巨大的优势，因为分配和取消分配辅助数组所需的时间是显而易见的。就地操作也提高了quicksort的位置。

在使用链表时，这些优点都不一定适用。因为链表单元常常分散在内存中，所以访问相邻的链表单元并没有局部性奖励。因此，quicksort的一个巨大性能优势被蚕食了。类似地，就地工作的好处不再适用，因为merge-sort的链表算法不需要任何额外的辅助存储空间。

也就是说，快速排序在链表上仍然非常快。合并排序往往更快，因为它更平均地将列表一分为二，而且每次迭代执行合并的工作量比执行分区步骤的工作量要少。
算法原理

快速排序对于每一层二叉树，遍历的次数是小于n的，比如说它在第二层就已经确定了一个点的位置，在第三层就已经确定了三个点的位置，在第四层确定了七个点的位置。越向下面的结点遍历，次数越少。

归并排序每次都要将n个数据合并，遍历的次数固定为n。

所以，在每一层的遍历，快速排序是比归并排序要高出0-50%的效率的

# 堆排序

## 概念

### 完全二叉树

一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树

![Image](https://photo.jiaoshen.top/img/Image.png)



### 大根堆

节点总小或等于父节点的完全二叉树

####  大根堆维护

1.数组维护结构

2.加元素，heapInsert

每次进来一个元素，比父节点小则与父节点互换

3.去根节点

1）把尾结点移到根节点

2）然后依次与最大的子节点比较互换

### 小根堆

节点总大于或等于父节点的完全二叉树



java自带的堆结构

```
PriorityQueue<Integer> heaps = new PriorityQueue<>();
```

##  堆排序步骤
1，先让整个数组都变成大根堆结构，建立堆的过程

从上到下的方法，时间复杂度为O（N*logN2）*

*从下到上的方法，时间复杂度为O（N）*

2.把堆的最大值和堆末尾的值交换，然后减少堆的大小之后，再去调整堆一直周而复始，时间复杂度为O（N*logN)

3.堆的大小减小成0之后，排序完成

## 堆的作用

优先级队列 -- 一般需要频繁入队和频繁把优先级最高的元素出队
堆适合处理流式数据啊，数组中每次进来一个新的数据，你难道得全部重新排序一下吗？显然不合适。

## 经典题目

大根堆的增加元素和删减元素。（改动后保持大根堆的结构）



1.给定很多线段，每个线段都有两个数[start, end]，表示线段开始位置和结束位置，左右都是闭区间规定：

1）线段的开始和结束位置一定都是整数值

2）线段重合区域的长度必须>=1返回线段最多重合区域中，包含了几条线段

2.TOPk问题：如何快速在 n个数中找出最大的k个数？

![image-20230102011419390](https://photo.jiaoshen.top/img/image-20230102011419390.png)

# 不基于比较的排序

## 1.计数排序 已知道排序的范围比较小

## 2.基数排序

复数解决方式：所有数加上最小数，拍完序再加回来先按个位排序，再按十位数排序，再按百位数排序出桶进桶用前缀和求

## 3.桶排序

# 总结

## 排序稳定性

排序算法的稳定性稳定性是指同样大小的样本再排序之后不会改相对次序

对基础类型来说，稳定性毫无意义

对非基础类型来说，稳定性有重要意义

有些排序算法可以实现成稳定的而有些排序算法无论如何都实现不成稳定的

4.1不稳定的排序堆排序，快速排序

## 排序算法总结

1）不基于比较的排序，对样本数据有严格要求，不易改写

2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用

3）基于比较的排序，时间复杂度的极限是O（N*logN）*

*4）时间复杂度O（N*logN）、额外空间复杂度低于ON）、且稳定的基于比较的排序是不存在的。

5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并