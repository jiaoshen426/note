# 概念
## 完全二叉树
一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树

![](https://photo.jiaoshen.top/img/202301021204844.png)

## 大根堆

节点总小或等于父节点

## 小根堆

节点总大于或等于父节点
## 平衡二叉树
平衡二叉树，又称AVL树
左子树和右子树的高度之差的绝对值小于等于1
左子树和右子树也是平衡二叉树
## 搜索二叉树
它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
# 技巧
二叉树的递归套路
1）假设以X节点为头，假设可以向X左树和X右树要任何信息
2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）
3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息把左树信息和右树信
4）息求全集，就是任何一棵子树都需要返回的信息S
5）递归函数都返回S，每一棵子树都这么要求
6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息
# 题目
1.题目寻找链表是否有环
1）用set排重
2）快指针（走两步），慢指针（走一步）相遇，相遇后满指针回到头结点，快指针改为走一步 他们会在首环节点相遇 （可以自己设置公式推理）

2.判断两个无环链表是否相交，只需要看尾结点是否一样

3.二叉树遍历
1）先序遍历 头左右
2）中序遍历 左头右
3）后序遍历 左右头
遍历的时候每个节点都会经过3次
只打印第一次经过的是先序
只打印第二次经过的是中序
只打印第三次经过的是后序

```
public static void readTree(TreeNode treeNode) {
    if (Objects.isNull(treeNode)) {
        return;
    }
    //先序遍历
    System.out.println(treeNode.getValue());
    readTree(treeNode.left);
    //中序遍历
    //System.out.println(treeNode.getValue());
    readTree(treeNode.right);
    //后序遍历
    //System.out.println(treeNode.getValue());
}
```

4.二叉树的非递归实现
5.二叉树的宽度遍历
6.二叉树的序列号与反序列化
先序和后序可以序列化，中序不能序列化 有歧义
按层遍历也可以序列化
7.多叉树转二叉树
https://leetcode.cn/problems/encode-n-ary-tree-to-binary-tree/
8.求二叉树的最大宽度
9.判断一个树是否完全二叉树
10.判断一个树是否平衡二叉树
11.判断一个树是否搜索二叉树
12派对的最大快乐值
员工信息的定义如下:
class Employee {
public int happy; // 这名员工可以带来的快乐值
List<Employee> subordinates; // 这名员工有哪些直接下级
}
公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树
树的头节点是公司唯一的老板，除老板之外的每个员工都有唯一的直接上级
叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外每个员工都有一个或多个直接下级
这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：
1.如果某个员工来了，那么这个员工的所有直接下级都不能来
2.派对的整体快乐值是所有到场员工快乐值的累加
3.你的目标是让派对的整体快乐值尽量大
给定一棵多叉树的头节点boss，请返回派对的最大快乐值。